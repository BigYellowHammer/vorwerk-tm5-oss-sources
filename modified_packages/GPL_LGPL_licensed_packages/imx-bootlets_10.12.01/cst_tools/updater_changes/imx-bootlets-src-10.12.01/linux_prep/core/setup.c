/*
 * Linux parameters setting code
 *
 * - Parse a command line linux_prep section
 *
 * - Detect a magic key combination to choice a proper
 *   command line
 *
 * - Generate a list of ARM tags handled by Linux kernel
 *
 * Vladislav Buzov <vbuzov@embeddedalley.com>
 *
 * Copyright 2008 SigmaTel, Inc
 * Copyright 2008 Embedded Alley Solutions, Inc
 * Copyright 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
 *
 * This file is licensed under the terms of the GNU General Public License
 * version 2.  This program  is licensed "as is" without any warranty of any
 * kind, whether express or implied.
 *
 * http://www.opensource.org/licenses/gpl-license.html
 * http://www.gnu.org/copyleft/gpl.html
 */
#include <setup.h>
#include <keys.h>
#include <stmp3xxx.h>
#include <arch/platform.h>
#include "debug.h"
#include "regsuartdbg.h"
#include "regspinctrl.h"

///////////////////////////////  HAB STUFF ////////////////////////////////
#include "hab.h" /* hab_ivt_t, IVT_HDR, HAB_VER */
#include "hab_types.h"
#include "hab_cmd.h"

extern char *__hab_data, *__hab_data_end;
extern int _start( void );

struct _hab_aut {
    hab_ivt_t ivt;
    uint32_t img_len;
};

const struct _hab_aut input_ivt __attribute__((section(".data"),aligned(4))) = {
    {
	// hdr word with tag #HAB_TAG_IVT, length and HAB version fields
	IVT_HDR(sizeof(hab_ivt_t), HAB_VER(4, 0)),
	// Absolute address of the first instruction to execute
	(hab_image_entry_f) (&_start),
	// Reserved in this version of HAB: should be NULL
	NULL,
	// Absolute address of the image DCD: may be NULL
	NULL,
	// Absolute address of the Boot Data: may be NULL, but not interpreted any further by HAB
	NULL,
	// Absolute address of the IVT
	(const void*) (&input_ivt),
	// Absolute address of the image CSF (CSF data generated by cst)
	(const void*) (&__hab_data),
	// Reserved in this version of HAB: should be zero.
	0
    },
    // image length including CSF data calculated from linker symbol __hab_data_end
    // and BASE_ADDR, defined in Makefile and used at compile time
    (((uint32_t) &__hab_data_end) - 0x00002000)
};

hab_rvt_t *hab_rvt_p = 0xFFFF8AF8;

///////////////////////////////  HAB STUFF ////////////////////////////////

void debug_init(void);
int get_hab_status(void);


static struct tag *params;
static char *cmdlines[MAGIC_KEY_NR];

/* minimal implementation of string functions */
static char *strstr(const char *s1, const char *s2)
{
	int i;

	if (*s1 == '\0')
		return *s2 ? 0 : (char *)s1;

	while (*s1) {
		for (i = 0; ; i++) {
			if (s2[i] == '\0')
				return (char *)s1;
			if (s2[i] != s1[i])
				break;
		}
		s1++;
	}
	return 0;
}

static int strlen(const char *s)
{
	const char *start = s;

	while (*s)
		s++;

	return s - start;
}

static char *strcpy(char *s1, const char *s2)
{
	char *s = s1;

	while ((*s1++ = *s2++) != '\0')
		;

	return s;
}

static void *memcpy(void *s1, const void *s2, int n)
{
	char *dst = s1;
	const char *src = s2;

	while (n-- > 0)
		*dst++ = *src++;

	return s1;
}

#ifdef MX28
#include "../../mach-mx28/includes/registers/regsrtc.h"
#elif defined(STMP378X)
#include "../../mach-mx23/includes/registers/regsrtc.h"
#endif

#define NAND_SECONDARY_BOOT          0x00000002

/***********************************************************************/

/*
 * Magic key detection
 */
static enum magic_key get_magic_key (void)
{
	u32 keys;
	int magic;
	
// MICHAL - disable magic keys check
//	/* Detect pressed keys */
//	keys = get_pressed_keys();
//
//	/*
//	 * Check if detected keys combination corresponds to
//	 * any magic key code
//	 */
//	for (magic = MAGIC_KEY1; magic < MAGIC_KEY_NR; magic++)
//		if (magic_keys[magic] == keys)
//			return magic;

	return NO_MAGIC_KEY;
}

/*
 * Command lines handling
 *
 * Go over a .cmdlines section. It must contatin \0 terminated
 * command lines storead one by one:
 *
 * 	command_line1\0command_line2\0command_line3\0
 *	|					     |
 * cmdlines_start				cmdlines_end
 */
static void find_command_lines (void)
{
	char *start = &cmdlines_start[0];
	char *end = &cmdlines_end[0];
	char *head, *cur;
	int l;

	head = cur = start;

	for (l = 0; l < MAGIC_KEY_NR && cur < end; l++) {

		/* Find a command line end */
		while (cur < end && *cur++ != '\0') ;

		/*
		 * If there is a garbage or unterminated command
		 * line at the end of the section then skip it.
		 */
		if (cur == end && *(cur-1) != '\0')
			break;

		cmdlines[l] = head;
		head = cur;
	}

	/*
	 * Bind default command line to magic keys not presented
	 * in .commandlines
	 */
	while (l < MAGIC_KEY_NR)
		cmdlines[l++] = cmdline_def;
}

/*
 * Calculate SDRAM size:
 *
 * size = #cs * 4 banks * #columns * #rows * 2 bytes/word
 */

#define MAX_ROW		13
#define MAX_COLUMN	12

static u32 get_sdram_size (void)
{
	u32 row, column, csmap, size;
	u32 cs = 0;

#ifdef SDRAM_SIZE
	return SDRAM_SIZE;
#endif

	row = MAX_ROW -
	      ((HW_DRAM_CTL10_RD() & BM_DRAM_CTL10_ADDR_PINS) >> 16);

	column = MAX_COLUMN -
		 ((HW_DRAM_CTL11_RD() & BM_DRAM_CTL11_COLUMN_SIZE) >> 8);

	csmap = HW_DRAM_CTL14_RD() & BM_DRAM_CTL14_CS_MAP;

/*
 * Calculate the number of 1 bits in csmap
 * x & (x - 1) 	- clears the least significant 1 bit.
 */
	while (csmap) {
		csmap &= (csmap - 1);
		cs++;
	}

	size = cs * 4 * (1 << row) * (1 << column) * 2;

	return size;
}

/*
 * ARM atags
 */
static void setup_start_tag (void)
{
	params = (struct tag*)ATAGS_BASE_ADDRESS;

	params->hdr.tag = ATAG_CORE;
	params->hdr.size = tag_size(tag_core);

	params->u.core.flags = 0;
	params->u.core.pagesize = 0;
	params->u.core.rootdev = 0;

	params = tag_next(params);
}

static void setup_mem_tag (void)
{
	params->hdr.tag = ATAG_MEM;
	params->hdr.size = tag_size(tag_mem32);

	params->u.mem.start = SDRAM_BASE;
	params->u.mem.size = get_sdram_size();

	params = tag_next(params);
}

static void setup_initrd_tag(void)
{
	params->hdr.tag = ATAG_INITRD2 ;
	params->hdr.size = tag_size(tag_initrd);

	params->u.initrd.start = 0x40800000;
	params->u.initrd.size =  0x00400000;

	params = tag_next(params);
}

static void setup_cmdline_tag (char *cmdline)
{

	u32 len;
	const char *mtdprefix[] = { "root=/dev/mtdblock", "root=ubi0:rootfs"};
	char *o, *m, *s, *rest;
	int nr, i, j, p, digits;
	unsigned int val;

	/* is a nand root present in the command line? */
	for (p = 0; p < sizeof(mtdprefix)/sizeof(mtdprefix[0]); p++) {
		m = strstr(cmdline, mtdprefix[p]);
		if (m)
			break;
	}

	if (!m)
		goto normal_copy;

	/* yes, we have to read the persistent bit now */

	/* start the RTC block */
	HW_RTC_CTRL_CLR(BM_RTC_CTRL_SFTRST | BM_RTC_CTRL_CLKGATE);

	while (HW_RTC_STAT_RD() & BF_RTC_STAT_STALE_REGS(0x1 << 1))
		;
	val = HW_RTC_PERSISTENT1_RD();

	/* normal boot, no need to modify cmdline */
	if ((val & NAND_SECONDARY_BOOT) == 0)
		goto normal_copy;

	/* add one to the rootfs partition number
	 * we assume that the secondary rootfs partition
	 * is the next one
	 */
	o = params->u.cmdline.cmdline;
	m += strlen(mtdprefix[p]);
	memcpy(o, cmdline, m - cmdline);
	o += m - cmdline;

	s = m;
	while (*s && *s >= '0' && *s <= '9')
		s++;

	rest = s;

	s--;
	nr = 0;
	while (s >= m) {
		nr = nr * 10 + (*s - '0');
		s--;
	}

	nr++;
	digits = 0;
	i = nr;
	while (i > 0) {
		digits++;
		i /= 10;
	}

	i = nr;
	j = digits;
	while (j > 0) {
		o[j - 1] = '0' + (i % 10);
		i /= 10;
		j--;
	}
	o += digits;
	strcpy(o, rest);

	goto done_copy;

normal_copy:
	/* Copy unchanged command line to SDRAM */
	strcpy(params->u.cmdline.cmdline, cmdline);

done_copy:
	/* Command line length including '\0' */
	len = strlen(params->u.cmdline.cmdline) + 1;

	params->hdr.tag = ATAG_CMDLINE;

	/*
	 * Tag size should be multiple of 4, so it is needed to round
	 * up a command line size.
	 */
	params->hdr.size = (sizeof(struct tag_header) + len + 4) >> 2;

	params = tag_next(params);
}

static void setup_end_tag (void)
{
	params->hdr.tag = ATAG_NONE;
	params->hdr.size = 0;
}

/*
 * External interface to set up tags in SDRAM
 * Returns a pointer to tag list in SDRAM
 *
 * The following tags are passed to kernel in addition to start and end
 * tags which must always exist:
 *
 * - Memory tag
 * - Command line tag
 */
u32 setup_tags (void)
{
	enum magic_key magic_key;

	// MICHAL
	debug_init();
	get_hab_status();

	magic_key = get_magic_key();
	find_command_lines();

	setup_start_tag();
	setup_mem_tag();
	setup_initrd_tag();
	setup_cmdline_tag(cmdlines[magic_key]);
	setup_end_tag();

	return (u32)ATAGS_BASE_ADDRESS;
}

void debug_init (void)
{
#ifdef TM41_DEBUG
	// on TM41 board below lines enables debug output for bootlets
	HW_PINCTRL_MUXSEL7_CLR(0xF000F);
	HW_PINCTRL_MUXSEL6_CLR(0xF0);
	HW_PINCTRL_MUXSEL6_SET(0xA0);
#else
	// boot rom wrong use debug uart port.
	// If fuse burned, the below two line can be removed.
	HW_PINCTRL_MUXSEL7_CLR(0xF);
	HW_PINCTRL_MUXSEL7_SET(0xA);

	/* Boot ROM set BANK3_PIN24 as debug uart rx.
	 * which cause uboot can't input */
	HW_PINCTRL_MUXSEL7_SET(0x30000);
#endif
}

int get_hab_status(void)
{
	uint32_t index = 0; /* Loop index */
	uint8_t event_data[128]; /* Event data buffer */
	size_t bytes = sizeof(event_data); /* Event size in bytes */
	hab_config_t config = 0;
	hab_state_t state = 0;
	int i;
	
	printf ("\nMICHAL UPDATER - get_hab_status():\n");
	/* Check HAB status */
	if (hab_rvt_p->report_status(&config, &state) != HAB_SUCCESS)
	{
		printf("\nHAB Configuration: 0x%h HAB State: 0x%h\n", config, state);
		/* Display HAB Failure events */
		while (hab_rvt_p->report_event(HAB_FAILURE, index, event_data, &bytes) == HAB_SUCCESS)
		{
			printf("\n");
			printf("---------HAB Event %d -----------------\n", index + 1);
			printf("event data:\n");
			/* display_event will simply prints out the contents of events_data */
			for (i = 0; i < bytes; i++)
			{
			    printf("0x%h ", event_data[i]);
			    if ((i % 4) == 3) {
			        printf(" ");
			    }
			}
			printf("\n");
			bytes = sizeof(event_data);
			index++;
		}
		/* Check reason for stopping */
		if (hab_rvt_p->report_event(HAB_STS_ANY, index, NULL, &bytes) == HAB_SUCCESS)
		{
			printf("ERROR: Recompile with larger event data buffer - at least %d bytes\n", bytes);
		}
	}
	/* Display message if no HAB Failure events are found */
	else
	{
		printf("\nHAB Configuration: 0x%h HAB State: 0x%h\n", config, state);
		printf("No HAB Failure Events Found!\n\n");
	}

	return 0;
}

/*
 * Image Chooser Prep
 *
 */

#include <stdarg.h>
#include <stddef.h>
#include "regsuartdbg.h"
#include "regsrtc.h"
#include "regsclkctrl.h"
#include "regsdigctl.h"
#include "regspinctrl.h"
#include "debug.h"
#include "chooser.h"
#include "itf_define.h"
#include "bootmode.h"

// chooser + romlib is below 24K in size, rom_ctx is about 8kB in size (assuming 2x 3000B buffers are used),
// BEWARE OF INCREASING SIZE OF CHOOSER_PREP ABOVE SPECIFIED LIMIT !

// had to increase from 30k to 34k because of additional HAB data 8kB, otherwise
// we would zero text/data segments!
#define FREE_AREA_ORIGIN	34000
#define FREE_AREA_SZ		10000

extern int m_u32UpdateStatus;
extern nand_BootItf_t rom_NandBootItf;


///////////////////////////////  HAB STUFF ////////////////////////////////

#include "hab.h" /* hab_ivt_t, IVT_HDR, HAB_VER */
#include "hab_types.h"
#include "hab_cmd.h"

extern char *__hab_data, *__hab_data_end;
// forward declaration
int _start (int arg);

struct _hab_aut {
    hab_ivt_t ivt;
    uint32_t img_len;
};

const struct _hab_aut input_ivt __attribute__((section(".data"),aligned(4))) = {
    {
	// hdr word with tag #HAB_TAG_IVT, length and HAB version fields
	IVT_HDR(sizeof(hab_ivt_t), HAB_VER(4, 0)),
	// Absolute address of the first instruction to execute
	(hab_image_entry_f) (&_start),
	// Reserved in this version of HAB: should be NULL
	NULL,
	// Absolute address of the image DCD: may be NULL
	NULL,
	// Absolute address of the Boot Data: may be NULL, but not interpreted any further by HAB
	NULL,
	// Absolute address of the IVT
	(const void*) (&input_ivt),
	// Absolute address of the image CSF (CSF data generated by cst)
	(const void*) (&__hab_data),
	// Reserved in this version of HAB: should be zero.
	0
    },
    // image length including CSF data calculated from linker symbol __hab_data_end
    // and BASE_ADDR, defined in Makefile and used at compile time
    (((uint32_t) &__hab_data_end) - 0x00000010)
};

///////////////////////////////  HAB STUFF ////////////////////////////////

// stub for __div0 in libgcc.a
void raise ()
{
}

void *memset (void *s, int c, size_t n) {
    unsigned char* p=s;
    while (n--)
	*p++ = (unsigned char) c;
    return s;
}

unsigned int get_update_status ()
{
    rom_BootInit_t init = {(void *)FREE_AREA_ORIGIN, FREE_AREA_SZ, BOOT_MODE_NAND_BCH, 0};

    // clear memory for rom_ctx structure
    memset ((void *)FREE_AREA_ORIGIN, 0, FREE_AREA_SZ);

    // Initialize the boot driver
    rom_BootItf_t * nandBootItf = &rom_NandBootItf;
    nandBootItf->Init (&init);

    return m_u32UpdateStatus;
}



/* Debug uart have been init by boot rom. */
void putc(char ch)
{
	int loop = 0;
	while (HW_UARTDBGFR_RD()&BM_UARTDBGFR_TXFF) {
		loop++;
		if (loop > 10000)
			break;
	};

	HW_UARTDBGDR_WR(ch);
}

void delay(unsigned int us)
{
	unsigned int start , cur;
	start = cur = HW_DIGCTL_MICROSECONDS_RD();

	while (cur < start+us) {
		cur = HW_DIGCTL_MICROSECONDS_RD();
	}
}

void soft_reset(void)
{
	// perform software reset
	delay (5000);	// delay so output will be shown
	HW_CLKCTRL_RESET_SET (BM_CLKCTRL_RESET_DIG);
	delay (5000);
}


int _start(int arg)
{
	unsigned int update_status;

#ifdef TM41_DEBUG
	// on TM41 board below lines enables debug output for bootlets
	HW_PINCTRL_MUXSEL7_CLR(0xF000F);
	HW_PINCTRL_MUXSEL6_CLR(0xF0);
	HW_PINCTRL_MUXSEL6_SET(0xA0);
#else
	// boot rom wrong use debug uart port.
	// If fuse burned, the below two line can be removed.
	HW_PINCTRL_MUXSEL7_CLR(0xF);
	HW_PINCTRL_MUXSEL7_SET(0xA);

	/* Boot ROM set BANK3_PIN24 as debug uart rx.
	 * which cause uboot can't input
	*/
	HW_PINCTRL_MUXSEL7_SET(0x30000);
#endif

	printf("-=-=-=-=-=-=-=-=-=-=-=-=-\r\n");
	printf("Image Chooser start\r\n");


	/* start the RTC block */
	HW_RTC_CTRL_CLR (BM_RTC_CTRL_SFTRST | BM_RTC_CTRL_CLKGATE);
	while (HW_RTC_STAT_RD() & BF_RTC_STAT_STALE_REGS(0x1 << 1));

	// read FCB block
	update_status = get_update_status();
	printf ("Update status in FCB is %d\r\n", update_status);

	// check which chooser bootlet we are
	if (HW_RTC_PERSISTENT1_RD() & TM41_BM_ROM_REDUNDANT_BOOT)
	{
		if (update_status == STATUS_NO_UPDATE_PENDING)
		{
			// recovery boot
			printf ("Image Chooser 1 (image 0 is unreadable, revert to image 1)\r\n");
			goto finish;
		}
		else if (update_status == STATUS_UPDATE_PENDING_TO_0)
		{
			if (HW_RTC_PERSISTENT2_RD() & TM41_BM_UPDATE_SWITCH_TO_0)
			{
				printf ("Image Chooser 1 (image 0 is unreadable after update, revert to image 1, should never happen!)\r\n");
				goto finish;
			}
			else
			{
				// update interrupted in phase 1, so boot image 1 that is known good
				printf ("Image Chooser 1 (interrupted update to image 0, revert to image 1)\r\n");
				goto finish;
			}
		}
		else if (update_status == STATUS_UPDATE_PENDING_TO_0_PHASE1_COMPLETED)
		{
			printf ("Image Chooser 1 - phase 1 completed (image 0 is unreadable after update to image 0, revert to image 1)\r\n");
			goto finish;
		}
		else if (update_status == STATUS_UPDATE_PENDING_TO_0_PHASE2_REACHED)
		{
			printf ("Image Chooser 1 - phase 2 reached (update to image 0, should never happen!)\r\n");
			goto finish;
		}
		else if (update_status == STATUS_UPDATE_PENDING_TO_1)
		{
			// update interrupted in phase 1, however we are already image 1, so best-effort
			// way is to try image 1, although it could be invalid
			printf ("Image Chooser 1 (interrupted update to image 1, revert to - probably invalid - image 1, should never happen!)\r\n");
			goto finish;
		}
		else if (update_status == STATUS_UPDATE_PENDING_TO_1_PHASE1_COMPLETED)
		{
			if (HW_RTC_PERSISTENT2_RD() & TM41_BM_UPDATE_SWITCH_TO_1)
			{
				// continue booting this stream
				printf ("Image Chooser 1 - phase 1 completed (update switchover to image 1)\r\n");
				goto finish;
			}
			else
			{
				// power off after completed phase 1 occured, but still continue with image 1
				printf ("Image Chooser 1 - phase 1 completed (interrupted update to image 1, continue image 1, should never happen!)\r\n");
				goto finish;
			}
		}
		else if (update_status == STATUS_UPDATE_PENDING_TO_1_PHASE2_REACHED)
		{
			printf ("Image Chooser 1 - phase 2 reached (continue image 1)\r\n");
			goto finish;
		}
		else if (update_status == STATUS_RECOVERY_CLONING_STARTED)
		{
			printf ("Image Chooser 1 (continue recovery)\r\n");
			goto finish;
		}
	}
	else
	{
		if (update_status == STATUS_NO_UPDATE_PENDING)
		{
			// normal boot
			printf ("Image Chooser 0 (normal boot)\r\n");
			goto finish;
		}
		else if (update_status == STATUS_UPDATE_PENDING_TO_0)
		{
			// update interrupted in phase 1, so boot image 1 that is known good
			// so it can clone-back
			printf ("Image Chooser 0 (interrupted update to image 0, revert to image 1)\r\n");
			// jump to other image using ROM loader mechanism
			HW_RTC_PERSISTENT1_SET (TM41_BM_ROM_REDUNDANT_BOOT);
			// perform software reset
			soft_reset();
		}
		else if (update_status == STATUS_UPDATE_PENDING_TO_0_PHASE1_COMPLETED)
		{
			if (HW_RTC_PERSISTENT2_RD() & TM41_BM_UPDATE_SWITCH_TO_0)
			{
				// continue booting this new image
				printf ("Image Chooser 0 - phase 1 completed (update switchover to image 0)\r\n");
				goto finish;
			}
			else
			{
				// update somehow was interrupted despite phase 1 completed,
				// so boot image 1 that is known good so it can clone-back
				printf ("Image Chooser 0 - phase 1 completed, but no persistant bit (revert to image 1)\r\n");
				// jump to other image using ROM loader mechanism
				HW_RTC_PERSISTENT1_SET (TM41_BM_ROM_REDUNDANT_BOOT);
				// perform software reset
				soft_reset();
			}
		}
		else if (update_status == STATUS_UPDATE_PENDING_TO_0_PHASE2_REACHED)
		{
			// continue booting this new image, as it booted fine before interruption
			// (hence no persistant bit check is required)
			printf ("Image Chooser 0 - phase 2 reached (update switchover to image 0)\r\n");
			goto finish;
		}
		else if (update_status == STATUS_UPDATE_PENDING_TO_1)
		{
			// update interrupted in phase 1, so boot image 0 that is known good
			// so it can clone-back
			printf ("Image Chooser 0 (interrupted update to image 1, revert to image 0)\r\n");
			goto finish;
		}
		else if (update_status == STATUS_UPDATE_PENDING_TO_1_PHASE1_COMPLETED)
		{
			if (HW_RTC_PERSISTENT2_RD() & TM41_BM_UPDATE_SWITCH_TO_1)
			{
				// continue booting new image
				printf ("Image Chooser 0 - phase 1 completed (update switchover to image 1)\r\n");
				// jump to other image using ROM loader mechanism
				HW_RTC_PERSISTENT1_SET (TM41_BM_ROM_REDUNDANT_BOOT);
				// perform software reset
				soft_reset();
			}
			else
			{
				// update somehow was interrupted despite phase 1 completed,
				// so boot image 0 that is known good so it can clone-back
				printf ("Image Chooser 0 - phase 1 completed, but no persistant bit (revert to image 0)\r\n");
				goto finish;
			}
		}
		else if (update_status == STATUS_UPDATE_PENDING_TO_1_PHASE2_REACHED)
		{
			// jump to new image, as it booted fine before interruption
			// (hence no persistant bit check is required)
			printf ("Image Chooser 0 - phase 2 reached (update switchover to image 1)\r\n");
			// jump to other image using ROM loader mechanism
			HW_RTC_PERSISTENT1_SET (TM41_BM_ROM_REDUNDANT_BOOT);
			// perform software reset
			soft_reset();
		}
		else if (update_status == STATUS_RECOVERY_CLONING_STARTED)
		{
			// interrupted during recovery 1->0, so jump to image 1 that is known to be good
			printf ("Image Chooser 0 (interrupted recovery, jump to image 1)\r\n");
			// jump to other image using ROM loader mechanism
			HW_RTC_PERSISTENT1_SET (TM41_BM_ROM_REDUNDANT_BOOT);
			// perform software reset
			soft_reset();
		}
	}


finish:
	printf("Image Chooser finish\r\n");

	return 0;
}

/* kiss gcc's ass to make it happy */
void __aeabi_unwind_cpp_pr0() {}
void __aeabi_unwind_cpp_pr1() {}
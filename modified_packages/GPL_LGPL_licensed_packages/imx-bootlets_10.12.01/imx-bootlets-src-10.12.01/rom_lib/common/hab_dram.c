#include "dat_common.h"
#include "hab.h"
#include "hab_types.h"
#include "hab_cmd.h"

#ifdef PITC_CALL
extern int32_t pitc_entry(uint32_t arg, uint32_t *pID);
#else
extern int start(uint32_t arg);
#endif

#pragma ghs section data=".ivt"
struct hab_ivt input_ivt ={
    /** @ref hdr word with tag #HAB_TAG_IVT, length and HAB version fields
     *  (see @ref data)
     */
    IVT_HDR(sizeof(struct hab_ivt), HAB_VER(4, 0)),
    /** Absolute address of the first instruction to execute from the
     *  image
     */
#ifdef PITC_CALL
    (hab_image_entry_f) (&pitc_entry),
#else
    (hab_image_entry_f) (&start),
#endif
    /** Reserved in this version of HAB: should be NULL. */
    NULL,
    /** Absolute address of the image DCD: may be NULL. */
    NULL,
    /** Absolute address of the Boot Data: may be NULL, but not interpreted
     *  any further by HAB
     */
    NULL,
    /** Absolute address of the IVT.*/
    (const void*) (&input_ivt),
    /** Absolute address of the image CSF.*/
    (const void*) 0x40302800,
    /** Reserved in this version of HAB: should be zero. */
    0
};

#pragma ghs section data=default

#pragma ghs section data=".length"
uint32_t input_bytes[4] = {
    0x4000, 0, 0, 0
};
#pragma ghs section data=default

#define MULTI_WRT_DAT(flags, bytes, number)                         \
    HDR(HAB_CMD_WRT_DAT, (number * 2 + 1) * 4, WRT_DAT_PAR((flags), (bytes)))

#pragma ghs section data="dcd"
uint8_t input_dcd[] = {
      /* DCD header */
      DCD_HDR(HDR_BYTES + 26 * WRT_DAT_BYTES + (63 * 2 + 1) * 4, HAB_VER(4,0)),

//void POWER_Init(void) just pick one register since no impact on RTL
//    HW_POWER_LOOPCTRL.B.EN_RCSCALE = 3;
WRT_DAT(0, HAB_DATA_WIDTH_WORD, 0x800440b4, 0x00003000),


// PLL already turn on by ROM
// HW_CLKCTRL_FRAC0_CLR(BM_CLKCTRL_FRAC0_CLKGATEEMI);
// Turn on fractional clock control 0 EMI clkgate, 
// setmem /32 0x800401b8=0x00008000
WRT_DAT(0, HAB_DATA_WIDTH_WORD, 0x800401b8, 0x00008000),


// Set up the EMI clock
//        case EMI_CLK_150MHz:
//            use_xtal_src = 0;
//            new_pll_frac_div = 29;   
//            new_pll_int_div = 2;     
// Write the PLL fractional divider W_CLKCTRL_FRAC0_WR(frac_val);
// Clear the EMI frac first 
WRT_DAT(0, HAB_DATA_WIDTH_WORD, 0x800401b8, 0x00003F00),
// write new_pll_frac_div
WRT_DAT(0, HAB_DATA_WIDTH_WORD, 0x800401b4, 29 << 8),

// Write the PLL EMI clock divider
// HW_CLKCTRL_EMI_WR(BF_CLKCTRL_EMI_CLKGATE(0) 
//   | BF_CLKCTRL_EMI_DIV_EMI(new_pll_int_div)
//   | BF_CLKCTRL_EMI_DIV_XTAL(new_xtal_int_div) );
WRT_DAT(0, HAB_DATA_WIDTH_WORD, 0x800400f0, (2 << 0) | (1 << 8)),

// while (HW_CLKCTRL_EMI_RD() &BM_CLKCTRL_EMI_BUSY_REF_EMI)
CHK_DAT_FOREVER(0, HAB_DATA_WIDTH_WORD, 0x800400f0, 0x10000000),

// Clear the PLL EMI-bypass bit so that the PLL clock takes over
// HW_CLKCTRL_CLKSEQ_CLR(BM_CLKCTRL_CLKSEQ_BYPASS_EMI);
WRT_DAT(0, HAB_DATA_WIDTH_WORD, 0x800401d8, 0x00000080),

// Set up the pinmux for the EMI
// must clear the HW_PINCTRL_CTRL_CLR to enable pinmux block clock --APB clock
// HW_PINCTRL_CTRL_CLR(BM_PINCTRL_CTRL_CLKGATE | BM_PINCTRL_CTRL_SFTRST);
WRT_DAT(0, HAB_DATA_WIDTH_WORD, 0x80018008, 0x40000000 | 0x80000000),

// Set drive strength 
// HW_PINCTRL_EMI_DS_CTRL_SET(
//        BF_PINCTRL_EMI_DS_CTRL_ADDRESS_MA(pin_drive_addr) |
//        BF_PINCTRL_EMI_DS_CTRL_CONTROL_MA(pin_drive_ctrl) |
//        BF_PINCTRL_EMI_DS_CTRL_DUALPAD_MA(pin_drive_clk) |
//        BF_PINCTRL_EMI_DS_CTRL_SLICE0_MA(pin_drive_data_slice_0) |
//	      BF_PINCTRL_EMI_DS_CTRL_SLICE1_MA(pin_drive_data_slice_1));
WRT_DAT(0, HAB_DATA_WIDTH_WORD, 0x80019b84, (1 << 8) | (1 << 2) | (1 << 0)),

// Configure Bank-6  EMI_D15 ~ EMI_D00 as EMI pins
// HW_PINCTRL_MUXSEL10_CLR(
//        BM_PINCTRL_MUXSEL10_BANK5_PIN15 | 
//        BM_PINCTRL_MUXSEL10_BANK5_PIN14 |
//        BM_PINCTRL_MUXSEL10_BANK5_PIN13 |
//        BM_PINCTRL_MUXSEL10_BANK5_PIN12 |
//        BM_PINCTRL_MUXSEL10_BANK5_PIN11 |
//        BM_PINCTRL_MUXSEL10_BANK5_PIN10 |
//        BM_PINCTRL_MUXSEL10_BANK5_PIN09 |
//        BM_PINCTRL_MUXSEL10_BANK5_PIN08 |
//        BM_PINCTRL_MUXSEL10_BANK5_PIN07 |
//        BM_PINCTRL_MUXSEL10_BANK5_PIN06 |
//        BM_PINCTRL_MUXSEL10_BANK5_PIN05 |
//        BM_PINCTRL_MUXSEL10_BANK5_PIN04 |
//        BM_PINCTRL_MUXSEL10_BANK5_PIN03 |
//        BM_PINCTRL_MUXSEL10_BANK5_PIN02 |
//        BM_PINCTRL_MUXSEL10_BANK5_PIN01 |
//        BM_PINCTRL_MUXSEL10_BANK5_PIN00 );
WRT_DAT(0, HAB_DATA_WIDTH_WORD, 0x800181a8, 0xffffffff),

// EMI_DDR_OPEN ,EMI_DQS1,EMI_DQS0,EMI_CLK,EMI_DDR_OPEN_FB,EMI_DQM1,EMI_ODT1,EMI_DQM0,EMI_ODT0
// HW_PINCTRL_MUXSEL11_CLR(
//	   BM_PINCTRL_MUXSEL11_BANK5_PIN26 |
//	   BM_PINCTRL_MUXSEL11_BANK5_PIN23 |
//	   BM_PINCTRL_MUXSEL11_BANK5_PIN22 |
//	   BM_PINCTRL_MUXSEL11_BANK5_PIN21 |
//	   BM_PINCTRL_MUXSEL11_BANK5_PIN20 |
//	   BM_PINCTRL_MUXSEL11_BANK5_PIN19 |
//	   BM_PINCTRL_MUXSEL11_BANK5_PIN18 |
//	   BM_PINCTRL_MUXSEL11_BANK5_PIN17 |
//	   BM_PINCTRL_MUXSEL11_BANK5_PIN16 );
WRT_DAT(0, HAB_DATA_WIDTH_WORD, 0x800181b8, 
    0x00300000 |
    0x0000C000 |
    0x00003000 |
    0x00000C00 |
    0x00000300 |
    0x000000C0 |
    0x00000030 |
    0x0000000C |
    0x00000003),

// EMI_A14 ~ EMI_A00
//    HW_PINCTRL_MUXSEL12_CLR(
//	  BM_PINCTRL_MUXSEL12_BANK6_PIN14 |
//	  BM_PINCTRL_MUXSEL12_BANK6_PIN13 |
//	  BM_PINCTRL_MUXSEL12_BANK6_PIN12 |
//	  BM_PINCTRL_MUXSEL12_BANK6_PIN11 |
//	  BM_PINCTRL_MUXSEL12_BANK6_PIN10 |
//	  BM_PINCTRL_MUXSEL12_BANK6_PIN09 |
//	  BM_PINCTRL_MUXSEL12_BANK6_PIN08 |
//	  BM_PINCTRL_MUXSEL12_BANK6_PIN07 |
//	  BM_PINCTRL_MUXSEL12_BANK6_PIN06 |
//	  BM_PINCTRL_MUXSEL12_BANK6_PIN05 |
//	  BM_PINCTRL_MUXSEL12_BANK6_PIN04 |
//	  BM_PINCTRL_MUXSEL12_BANK6_PIN03 |
//	  BM_PINCTRL_MUXSEL12_BANK6_PIN02 |
//	  BM_PINCTRL_MUXSEL12_BANK6_PIN01 |
//	  BM_PINCTRL_MUXSEL12_BANK6_PIN00 );
WRT_DAT(0, HAB_DATA_WIDTH_WORD, 0x800181c8, 0x3FFFFFF),

// EMI_CKE,EMI_CE1N,EMI_CE0N,EMI_WEN,EMI_RASN,EMI_CASN,EMI_BA2,EMI_BA1,EMI_BA0
//    HW_PINCTRL_MUXSEL13_CLR(
//    BM_PINCTRL_MUXSEL13_BANK6_PIN24 |
//    BM_PINCTRL_MUXSEL13_BANK6_PIN23 |
//    BM_PINCTRL_MUXSEL13_BANK6_PIN22 |
//    BM_PINCTRL_MUXSEL13_BANK6_PIN21 |
//    BM_PINCTRL_MUXSEL13_BANK6_PIN20 |
//    BM_PINCTRL_MUXSEL13_BANK6_PIN19 |
//    BM_PINCTRL_MUXSEL13_BANK6_PIN18 |
//    BM_PINCTRL_MUXSEL13_BANK6_PIN17 |
//    BM_PINCTRL_MUXSEL13_BANK6_PIN16 );
WRT_DAT(0, HAB_DATA_WIDTH_WORD, 0x800181d8, 0x0003FFFF),

//void PINCTRL_DisableEmiPadKeepers(void)
// Disable the internal bus-keeper pins associated with EMI.
// HW_PINCTRL_PULL5_SET(
//        BM_PINCTRL_PULL5_BANK5_PIN26 |
//        BM_PINCTRL_PULL5_BANK5_PIN23 |
//        BM_PINCTRL_PULL5_BANK5_PIN22 |
//        BM_PINCTRL_PULL5_BANK5_PIN21 |
//        BM_PINCTRL_PULL5_BANK5_PIN20 |
//        BM_PINCTRL_PULL5_BANK5_PIN19 |
//        BM_PINCTRL_PULL5_BANK5_PIN18 |
//        BM_PINCTRL_PULL5_BANK5_PIN17 |
//        BM_PINCTRL_PULL5_BANK5_PIN16 |
//        BM_PINCTRL_PULL5_BANK5_PIN07 |
//        BM_PINCTRL_PULL5_BANK5_PIN06 |
//        BM_PINCTRL_PULL5_BANK5_PIN05 |
//        BM_PINCTRL_PULL5_BANK5_PIN04 |
//        BM_PINCTRL_PULL5_BANK5_PIN03 |
//        BM_PINCTRL_PULL5_BANK5_PIN02 |
//        BM_PINCTRL_PULL5_BANK5_PIN01 |
//        BM_PINCTRL_PULL5_BANK5_PIN00  );
WRT_DAT(0, HAB_DATA_WIDTH_WORD, 0x80018654, 0x04FF00FF),

//    HW_PINCTRL_PULL6_SET(
//        BM_PINCTRL_PULL6_BANK6_PIN24 |
//        BM_PINCTRL_PULL6_BANK6_PIN23 |
//        BM_PINCTRL_PULL6_BANK6_PIN22 |
//        BM_PINCTRL_PULL6_BANK6_PIN21 |
//        BM_PINCTRL_PULL6_BANK6_PIN20 |
//        BM_PINCTRL_PULL6_BANK6_PIN19 |
//        BM_PINCTRL_PULL6_BANK6_PIN18 |
//        BM_PINCTRL_PULL6_BANK6_PIN17 |
//        BM_PINCTRL_PULL6_BANK6_PIN16 |
//        BM_PINCTRL_PULL6_BANK6_PIN14 |
//        BM_PINCTRL_PULL6_BANK6_PIN13 |
//        BM_PINCTRL_PULL6_BANK6_PIN12 |
//        BM_PINCTRL_PULL6_BANK6_PIN11 |
//        BM_PINCTRL_PULL6_BANK6_PIN10 |
//        BM_PINCTRL_PULL6_BANK6_PIN08 |
//        BM_PINCTRL_PULL6_BANK6_PIN09 |
//        BM_PINCTRL_PULL6_BANK6_PIN07 |
//        BM_PINCTRL_PULL6_BANK6_PIN06 |
//        BM_PINCTRL_PULL6_BANK6_PIN05 |
//        BM_PINCTRL_PULL6_BANK6_PIN04 |
//        BM_PINCTRL_PULL6_BANK6_PIN03 |
//        BM_PINCTRL_PULL6_BANK6_PIN02 |
//        BM_PINCTRL_PULL6_BANK6_PIN01 |
//        BM_PINCTRL_PULL6_BANK6_PIN00 );
WRT_DAT(0, HAB_DATA_WIDTH_WORD, 0x80018664, 0x01ffffff),

// Program up the simmemsel to use the specified device
// HW_SIMMEMSEL_CFG_WR
WRT_DAT(0, HAB_DATA_WIDTH_WORD, 0x8003c400, 0x00030204),
// HW_SIMMEMSEL_CE_CFG_WR 
WRT_DAT(0, HAB_DATA_WIDTH_WORD, 0x8003c404, 0x00000000),

// enable EMI_CLK output     
// HW_DRAM_CTL00_SET(0x00000001);
WRT_DAT(0, HAB_DATA_WIDTH_WORD, 0x800e0000, 0x00000001),

//Initialize EMI...
// HW_DRAM_CTL16_CLR(0x00000001); //clear "start"  ??????
WRT_DAT(0, HAB_DATA_WIDTH_WORD, 0x800e0040, 0x00000000),

// init_dram_regs(); // Write the Databahn SDRAM setup register values
// use mobile_ddr_mt46h32m16lf_5_150MHz_for_dcd.c -- for 150MHz mDDR, 63 entries
MULTI_WRT_DAT(0, HAB_DATA_WIDTH_WORD, 63),
//    DRAM_REG[0] =    0x00000000;  //00000000000000000000000000000000 user_def_reg_0(RW) 
EXPAND_UINT32(0x800e0000 + 0 * 4), EXPAND_UINT32(0x00000000),
//    DRAM_REG[16] =    0x00000000; //0000000_0 write_modereg(WR) 0000000_0 power_down(RW) 000000000000000_0 start(RW) 
EXPAND_UINT32(0x800e0000 + 16 * 4), EXPAND_UINT32(0x00000000),
//    DRAM_REG[21] =    0x00000000; //00000_000 cke_delay(RW) 00000000 dll_lock(RD) 0000000_0 dlllockreg(RD) 0000000_0 dll_bypass_mode(RW) 
EXPAND_UINT32(0x800e0000 + 21 * 4), EXPAND_UINT32(0x00000000),
//    DRAM_REG[26] =    0x00010101; //000000000000000_1 priority_en(RW) 0000000_1 addr_cmp_en(RW) 0000000_1 placement_en(RW) 
EXPAND_UINT32(0x800e0000 + 26 * 4), EXPAND_UINT32(0x00010101),
//    DRAM_REG[27] =    0x01010101; //0000000_1 swap_port_rw_same_en(RW) 0000000_1 swap_en(RW) 0000000_1 bank_split_en(RW) 0000000_1 rw_same_en(RW) 
EXPAND_UINT32(0x800e0000 + 27 * 4), EXPAND_UINT32(0x01010101),
//    DRAM_REG[28] =    0x000f0f01; //00000_000 q_fullness(RW) 0000_1111 age_count(RW) 0000_1111 command_age_count(RW) 0000000_1 active_aging(RW) 
EXPAND_UINT32(0x800e0000 + 28 * 4), EXPAND_UINT32(0x000f0f01),
//    DRAM_REG[29] =    0x0f02020a; //0000_1111 cs_map(RW) 00000_010 column_size(RW) 00000_010 addr_pins(RW) 0000_1010 aprebit(RW) 
EXPAND_UINT32(0x800e0000 + 29 * 4), EXPAND_UINT32(0x0f02020a),
//    DRAM_REG[30] =    0x00000000; //0000000000000_000 max_cs_reg(RD) 0000_0000 max_row_reg(RD) 0000_0000 max_col_reg(RD) 
EXPAND_UINT32(0x800e0000 + 30 * 4), EXPAND_UINT32(0x00000000),
//    DRAM_REG[31] =    0x00000101; //000000000000000_0 eight_bank_mode(RW) 0000000_1 drive_dq_dqs(RW) 0000000_1 dqs_n_en(RW) 
EXPAND_UINT32(0x800e0000 + 31 * 4), EXPAND_UINT32(0x00000101),
//    DRAM_REG[32] =    0x00000100; //00000000000000000000000_1 reduc(RW) 0000000_0 reg_dimm_enable(RW) 
EXPAND_UINT32(0x800e0000 + 32 * 4), EXPAND_UINT32(0x00000100),
//    DRAM_REG[33] =    0x00000100; //00000000000000000000000_1 concurrentap(RW) 0000000_0 ap(RW) 
EXPAND_UINT32(0x800e0000 + 33 * 4), EXPAND_UINT32(0x00000100),
//    DRAM_REG[34] =    0x01000000; //0000000_1 writeinterp(RW) 0000000_0 intrptwritea(RW) 0000000_0 intrptreada(RW) 0000000_0 intrptapburst(RW) 
EXPAND_UINT32(0x800e0000 + 34 * 4), EXPAND_UINT32(0x01000000),
//    DRAM_REG[35] =    0x00000002; //000000000000000_0 pwrup_srefresh_exit(RW) 0000000_0 no_cmd_init(RW) 0000_0010 initaref(RW) 
EXPAND_UINT32(0x800e0000 + 35 * 4), EXPAND_UINT32(0x00000002),
//    DRAM_REG[36] =    0x01010000; //0000000_1 tref_enable(RW) 0000000_1 tras_lockout(RW) 000000000000000_0 fast_write(RW) 
EXPAND_UINT32(0x800e0000 + 36 * 4), EXPAND_UINT32(0x01010000),
//    DRAM_REG[37] =    0x07060301; //0000_0111 caslat_lin_gate(RW) 0000_0110 caslat_lin(RW) 00000_011 caslat(RW) 0000_0001 wrlat(RW) 
EXPAND_UINT32(0x800e0000 + 37 * 4), EXPAND_UINT32(0x07060301),
//    DRAM_REG[38] =    0x06000001; //000_00110 tdal(RW) 0000000000000000 tcpd(RW) 00000_001 tcke(RW) 
EXPAND_UINT32(0x800e0000 + 38 * 4), EXPAND_UINT32(0x06000001),
//    DRAM_REG[39] =    0x0a000000; //00_001010 tfaw(RW) 000000000000000000000000 tdll(RW) 
EXPAND_UINT32(0x800e0000 + 39 * 4), EXPAND_UINT32(0x0a000000),
//    DRAM_REG[40] =    0x02000020; // shorten tinit for simulation    
EXPAND_UINT32(0x800e0000 + 40 * 4), EXPAND_UINT32(0x02000020),
//    DRAM_REG[41] =    0x00020309; //0000000000000010 tpdex(RW) 00000011 trcd_int(RW) 00_001001 trc(RW) 
EXPAND_UINT32(0x800e0000 + 41 * 4), EXPAND_UINT32(0x00020309),
//    DRAM_REG[42] =    0x0028f506; //000000000010100011110101 tras_max(RW) 00000110 tras_min(RW) 
EXPAND_UINT32(0x800e0000 + 42 * 4), EXPAND_UINT32(0x0028f506),
//    DRAM_REG[43] =    0x030f048b; //0000_0011 trp(RW) 00001111 trfc(RW) 00_00010010001011 tref(RW) 
EXPAND_UINT32(0x800e0000 + 43 * 4), EXPAND_UINT32(0x030f048b),
//    DRAM_REG[44] =    0x03030002; //0000_0011 twtr(RW) 000_00011 twr_int(RW) 00000_000 trtp(RW) 00000_010 trrd(RW) 
EXPAND_UINT32(0x800e0000 + 44 * 4), EXPAND_UINT32(0x03030002),
//    DRAM_REG[45] =    0x00150012; //0000000000010101 txsr(RW) 0000000000010010 txsnr(RW) 
EXPAND_UINT32(0x800e0000 + 45 * 4), EXPAND_UINT32(0x00150012),
//    DRAM_REG[48] =    0x00011900; //0_0000000 axi0_current_bdw(RD) 0000000_1 axi0_bdw_ovflow(RW) 0_0100001 axi0_bdw(RW) 000000_00 axi0_fifo_type_reg(RW) 
EXPAND_UINT32(0x800e0000 + 48 * 4), EXPAND_UINT32(0x00011900),
//    DRAM_REG[49] =    0xffff0303;
EXPAND_UINT32(0x800e0000 + 49 * 4), EXPAND_UINT32(0xffff0303),
//    DRAM_REG[52] =    0x00011900; //0_0000000 axi2_current_bdw(RD) 0000000_1 axi2_bdw_ovflow(RW) 0_0100001 axi2_bdw(RW) 000000_00 axi2_fifo_type_reg(RW)     
EXPAND_UINT32(0x800e0000 + 52 * 4), EXPAND_UINT32(0x00011900),
//    DRAM_REG[53] =    0xffff0303;
EXPAND_UINT32(0x800e0000 + 53 * 4), EXPAND_UINT32(0xffff0303),
//    DRAM_REG[54] =    0x00011900; //0_0000000 axi3_current_bdw(RD) 0000000_1 axi3_bdw_ovflow(RW) 0_0100001 axi3_bdw(RW) 000000_00 axi3_fifo_type_reg(RW) 
EXPAND_UINT32(0x800e0000 + 54 * 4), EXPAND_UINT32(0x00011900),
//    DRAM_REG[55] =    0xffff0303;
EXPAND_UINT32(0x800e0000 + 55 * 4), EXPAND_UINT32(0xffff0303),
//    DRAM_REG[56] =    0x00000003; //00000000000000000000000000000_011 arb_cmd_q_threshold(RW) 
EXPAND_UINT32(0x800e0000 + 56 * 4), EXPAND_UINT32(0x00000003),
//    DRAM_REG[58] =    0x00000000; //00000_00000000000 int_status(RD) 00000_00000000000 int_mask(RW) 
EXPAND_UINT32(0x800e0000 + 58 * 4), EXPAND_UINT32(0x00000000),
//    DRAM_REG[66] =    0x0000048b; //000000000000_0000 tdfi_ctrlupd_min(RD) 00_00010010001011 tdfi_ctrlupd_max(RW) 
EXPAND_UINT32(0x800e0000 + 66 * 4), EXPAND_UINT32(0x0000048b),
//    DRAM_REG[67] =    0x01000f02; //0000_0001 tdfi_dram_clk_enable(RW) 00000_000 tdfi_dram_clk_disable(RW) 0000_0000 dram_clk_disable(RW) 0000_0010 tdfi_ctrl_delay(RW) 
EXPAND_UINT32(0x800e0000 + 67 * 4), EXPAND_UINT32(0x01000f02),
//    DRAM_REG[68] =    0x048b048b; //00_00010010001011 tdfi_phyupd_type0(RW) 00_00010010001011 tdfi_phyupd_resp(RW) 
EXPAND_UINT32(0x800e0000 + 68 * 4), EXPAND_UINT32(0x048b048b),
//    DRAM_REG[69] =    0x00000200; //00000000000000000000_0010 tdfi_phy_wrlat_base(RW) 0000_0000 tdfi_phy_wrlat(RD) 
EXPAND_UINT32(0x800e0000 + 69 * 4), EXPAND_UINT32(0x00000200),
//    DRAM_REG[70] =    0x00020007; //000000000000_0010 tdfi_rddata_en_base(RW) 0000_0000 tdfi_rddata_en(RD) 0000_0111 tdfi_phy_rdlat(RW) 
EXPAND_UINT32(0x800e0000 + 70 * 4), EXPAND_UINT32(0x00020007),
//    DRAM_REG[71] =    0xf3004a27; //11110100000000000100101000100111 phy_ctrl_reg_0_0(RW) 
EXPAND_UINT32(0x800e0000 + 71 * 4), EXPAND_UINT32(0xf3004a27),
//    DRAM_REG[72] =    0xf3004a27; //11110100000000000100101000100111 phy_ctrl_reg_0_1(RW) 
EXPAND_UINT32(0x800e0000 + 72 * 4), EXPAND_UINT32(0xf3004a27),
//    DRAM_REG[75] =    0x07400310; //00000111010000000000001100010000 phy_ctrl_reg_1_0(RW) 
EXPAND_UINT32(0x800e0000 + 75 * 4), EXPAND_UINT32(0x07400310),
//    DRAM_REG[76] =    0x07400310; //00000111010000000000001100010000 phy_ctrl_reg_1_1(RW) 
EXPAND_UINT32(0x800e0000 + 76 * 4), EXPAND_UINT32(0x07400310),
//    DRAM_REG[79] =    0x00800004; //00000000100000000000000000000101 phy_ctrl_reg_2(RW) 
EXPAND_UINT32(0x800e0000 + 79 * 4), EXPAND_UINT32(0x00800004),
//    DRAM_REG[82] =    0x01000000; //0000000_1 odt_alt_en(RW) 000000000000000000000000
EXPAND_UINT32(0x800e0000 + 82 * 4), EXPAND_UINT32(0x01000000),
//    DRAM_REG[83] =    0x01020408; //0000_0001 odt_rd_map_cs3(RW) 0000_0010 odt_rd_map_cs2(RW) 0000_0100 odt_rd_map_cs1(RW) 0000_1000 odt_rd_map_cs0(RW) 
EXPAND_UINT32(0x800e0000 + 83 * 4), EXPAND_UINT32(0x01020408),
//    DRAM_REG[84] =    0x08040201; //0000_1000 odt_wr_map_cs3(RW) 0000_0100 odt_wr_map_cs2(RW) 0000_0010 odt_wr_map_cs1(RW) 0000_0001 odt_wr_map_cs0(RW) 
EXPAND_UINT32(0x800e0000 + 84 * 4), EXPAND_UINT32(0x08040201),
//    DRAM_REG[85] =    0x000f1133; //00000000000011110001000100110011 pad_ctrl_reg_0(RW)    
EXPAND_UINT32(0x800e0000 + 85 * 4), EXPAND_UINT32(0x000f1133),
//    DRAM_REG[87] =    0x00089f30; //00000000000010001001111100110000 dll_ctrl_reg_0_0(RW) 
EXPAND_UINT32(0x800e0000 + 87 * 4), EXPAND_UINT32(0x00089f30),
//    DRAM_REG[88] =    0x00089f30; //00000000000010001001111100110000 dll_ctrl_reg_0_1(RW) 
EXPAND_UINT32(0x800e0000 + 88 * 4), EXPAND_UINT32(0x00089f30),
//    DRAM_REG[91] =    0x00081f0d; //00000000000010000001111100001101 dll_ctrl_reg_1_0(RW) 
EXPAND_UINT32(0x800e0000 + 91 * 4), EXPAND_UINT32(0x00081f0d),
//    DRAM_REG[92] =    0x00081f0d; //00000000000010000001111100001101 dll_ctrl_reg_1_1(RW)  
EXPAND_UINT32(0x800e0000 + 92 * 4), EXPAND_UINT32(0x00081f0d),
//    DRAM_REG[162] =   0x00000000; //00000_000 w2r_samecs_dly(RW) 00000_000 w2r_diffcs_dly(RW) 0000000_000000000
EXPAND_UINT32(0x800e0000 + 162 * 4), EXPAND_UINT32(0x00000000),
//    DRAM_REG[163] =   0x00010301; //00000000 dll_rst_adj_dly(RW) 0000_0001 wrlat_adj(RW) 0000_0011 rdlat_adj(RW) 0000_0001 dram_class(RW) 
EXPAND_UINT32(0x800e0000 + 163 * 4), EXPAND_UINT32(0x00010301),
//    DRAM_REG[164] =   0x00000002; //00000000000000_0000000000 int_ack(WR) 00000010 tmod(RW) 
EXPAND_UINT32(0x800e0000 + 164 * 4), EXPAND_UINT32(0x00000002),
//    DRAM_REG[171] =   0x01010000; //0000000_1 axi5_bdw_ovflow(RW) 0000000_1 axi4_bdw_ovflow(RW) 0000000000000000 dll_rst_delay(RW) 
EXPAND_UINT32(0x800e0000 + 171 * 4), EXPAND_UINT32(0x01010000),
//    DRAM_REG[172] =   0x01000100; //0000000_1 resync_dll_per_aref_en(RW) 0000000_0 resync_dll(WR) 0000000_1 concurrentap_wr_only(RW) 0000000_0 cke_status(RD) 
EXPAND_UINT32(0x800e0000 + 172 * 4), EXPAND_UINT32(0x01000100),
//    DRAM_REG[173] =   0x00000000; //00000_011 axi4_w_priority(RW) 00000_011 axi4_r_priority(RW) 000000_00 axi5_fifo_type_reg(RW) 000000_00 axi4_fifo_type_reg(RW) 
EXPAND_UINT32(0x800e0000 + 173 * 4), EXPAND_UINT32(0x00000000),
//    DRAM_REG[174] =   0x00020303; //00000_000 r2r_samecs_dly(RW) 00000_010 r2r_diffcs_dly(RW) 00000_011 axi5_w_priority(RW) 00000_011 axi5_r_priority(RW) 
EXPAND_UINT32(0x800e0000 + 174 * 4), EXPAND_UINT32(0x00020303),
//    DRAM_REG[175] =   0x01010202; //00000_001 w2w_diffcs_dly(RW) 00000_001 tbst_int_interval(RW) 00000_010 r2w_samecs_dly(RW) 00000_010 r2w_diffcs_dly(RW) 
EXPAND_UINT32(0x800e0000 + 175 * 4), EXPAND_UINT32(0x01010202),
//    DRAM_REG[176] =   0x00000000; //0000_0000 add_odt_clk_sametype_diffcs(RW) 0000_0000 add_odt_clk_difftype_samecs(RW) 0000_0000 add_odt_clk_difftype_diffcs(RW) 00000_000 w2w_samecs_dly(RW) 
EXPAND_UINT32(0x800e0000 + 176 * 4), EXPAND_UINT32(0x00000000),
//    DRAM_REG[177] =   0x01030101; //000_00001 tccd(RW) 0000_0011 trp_ab(RW) 0000_0001 cksrx(RW) 0000_0001 cksre(RW) 
EXPAND_UINT32(0x800e0000 + 177 * 4), EXPAND_UINT32(0x01030101),
//    DRAM_REG[178] =   0x01001901; //0_0100001 axi5_bdw(RW) 0_0000000 axi4_current_bdw(RD) 0_0100001 axi4_bdw(RW) 000_00001 tckesr(RW) 
EXPAND_UINT32(0x800e0000 + 178 * 4), EXPAND_UINT32(0x01001901),
//    DRAM_REG[181] =   0x00320032; //0_000000000110010 mr0_data_1(RW) 0_000000000110010 mr0_data_0(RW) 
EXPAND_UINT32(0x800e0000 + 181 * 4), EXPAND_UINT32(0x00320032),
//    DRAM_REG[183] =   0x00000000; //0_000000000000000 mr1_data_1(RW) 0_000000000000000 mr1_data_0(RW) 
EXPAND_UINT32(0x800e0000 + 183 * 4), EXPAND_UINT32(0x00000000),
//    DRAM_REG[189] =   0xffffffff;
EXPAND_UINT32(0x800e0000 + 189 * 4), EXPAND_UINT32(0xffffffff),

//     HW_DRAM_CTL17.B.SREFRESH = 0;
WRT_DAT(0, HAB_DATA_WIDTH_WORD, 0x800e0044, 0x00000000),
//     HW_DRAM_CTL16_SET(0x00000001);  //set "start"
WRT_DAT(0, HAB_DATA_WIDTH_WORD, 0x800e0040, 0x00000001),

// temp = HW_DRAM_CTL58_RD();  //Wait for EMI initization completed
// while ( (temp & 0x00100000) != 0x00100000 ){
// temp = HW_DRAM_CTL58_RD();
CHK_DAT_FOREVER(HAB_CMD_CHK_DAT_SET, HAB_DATA_WIDTH_WORD, 0x800e00e8, 0x00100000),

WRT_DAT(0, HAB_DATA_WIDTH_WORD, 0x40200000, 0xdeadbeef),
WRT_DAT(0, HAB_DATA_WIDTH_WORD, 0x40200400, 0x12345678),

CHK_DAT_FOREVER(HAB_CMD_CHK_DAT_SET, HAB_DATA_WIDTH_WORD, 0x40200000, 0xdeadbeef),
CHK_DAT_FOREVER(HAB_CMD_CHK_DAT_SET, HAB_DATA_WIDTH_WORD, 0x40200400, 0x12345678),
};

#pragma ghs section data=default

